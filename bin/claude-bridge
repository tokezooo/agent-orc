#!/usr/bin/env python3
"""
claude-bridge: Claude Code CLI as a Claude Code team member.

Registers as a member in a Claude Code agent team (file-based protocol)
and translates assigned tasks into Claude Code CLI runs.

Usage:
    claude-bridge join  --team <name> --name claude-worker --project <path> [options]
    claude-bridge leave --team <name> --name claude-worker

No external dependencies. Python 3.9+.
"""
from __future__ import annotations

import argparse
import fcntl
import json
import os
import signal
import subprocess
import sys
import tempfile
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

CLAUDE_HOME = Path.home() / ".claude"
TEAMS_DIR = CLAUDE_HOME / "teams"
TASKS_DIR = CLAUDE_HOME / "tasks"

DEFAULT_POLL_INTERVAL = 3.0
DEFAULT_TASK_TIMEOUT = 600
DEFAULT_MODEL = None  # use claude's default

DEEP_KEYWORDS = frozenset({
    "refactor", "plan", "complex", "architect", "redesign",
    "migration", "rewrite", "multi-file", "multifile",
})


# ---------------------------------------------------------------------------
# File locking (fcntl.flock)
# ---------------------------------------------------------------------------

class FileLock:
    """Exclusive lock via fcntl.flock on a companion .lock file."""

    def __init__(self, path: Path):
        self.lock_path = path.parent / (path.name + ".lock")
        self._fd: int | None = None

    def __enter__(self) -> "FileLock":
        self.lock_path.parent.mkdir(parents=True, exist_ok=True)
        self._fd = os.open(str(self.lock_path), os.O_CREAT | os.O_RDWR)
        fcntl.flock(self._fd, fcntl.LOCK_EX)
        return self

    def __exit__(self, *exc: object) -> None:
        if self._fd is not None:
            fcntl.flock(self._fd, fcntl.LOCK_UN)
            os.close(self._fd)
            self._fd = None


# ---------------------------------------------------------------------------
# Atomic JSON helpers
# ---------------------------------------------------------------------------

def _read_json(path: Path, default: Any = None) -> Any:
    """Read JSON from *path*; return *default* on missing/corrupt file."""
    if not path.exists():
        return default
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except (json.JSONDecodeError, OSError):
        return default


def _write_json_atomic(path: Path, data: Any) -> None:
    """Write *data* as JSON via tmp-file + rename for atomicity."""
    path.parent.mkdir(parents=True, exist_ok=True)
    content = json.dumps(data, ensure_ascii=False, indent=2) + "\n"
    fd, tmp_path = tempfile.mkstemp(dir=str(path.parent), suffix=".tmp")
    try:
        with os.fdopen(fd, "w", encoding="utf-8") as f:
            f.write(content)
        os.rename(tmp_path, str(path))
    except BaseException:
        try:
            os.unlink(tmp_path)
        except OSError:
            pass
        raise


def _now_ms() -> int:
    """Current UTC timestamp in milliseconds (for joinedAt)."""
    return int(datetime.now(timezone.utc).timestamp() * 1000)


def _now_iso() -> str:
    """ISO-8601 UTC timestamp with millisecond precision."""
    return (
        datetime.now(timezone.utc)
        .isoformat(timespec="milliseconds")
        .replace("+00:00", "Z")
    )


# ---------------------------------------------------------------------------
# Path helpers
# ---------------------------------------------------------------------------

def _team_dir(team: str) -> Path:
    return TEAMS_DIR / team


def _config_path(team: str) -> Path:
    return _team_dir(team) / "config.json"


def _inbox_path(team: str, name: str) -> Path:
    return _team_dir(team) / "inboxes" / f"{name}.json"


def _tasks_dir(team: str) -> Path:
    return TASKS_DIR / team


# ---------------------------------------------------------------------------
# Team registration
# ---------------------------------------------------------------------------

def register(team: str, name: str, project_dir: str) -> None:
    """Add (or update) this worker in the team config.json and create inbox."""
    cfg_path = _config_path(team)
    with FileLock(cfg_path):
        config = _read_json(cfg_path, {})
        members: list = config.setdefault("members", [])
        config["members"] = [m for m in members if m.get("name") != name]
        config["members"].append({
            "agentId": f"{name}@{team}",
            "name": name,
            "agentType": "claude-bridge",
            "model": "claude-code",
            "color": "blue",
            "joinedAt": _now_ms(),
            "cwd": project_dir,
            "subscriptions": [],
            "backendType": "claude-bridge",
            "isActive": True,
            "mode": "default",
        })
        _write_json_atomic(cfg_path, config)

    ib = _inbox_path(team, name)
    if not ib.exists():
        _write_json_atomic(ib, [])


def deregister(team: str, name: str) -> None:
    """Set isActive=false for this worker in the team config.json."""
    cfg_path = _config_path(team)
    with FileLock(cfg_path):
        config = _read_json(cfg_path, {})
        for m in config.get("members", []):
            if m.get("name") == name:
                m["isActive"] = False
        _write_json_atomic(cfg_path, config)


def _find_leader(team: str, my_name: str) -> Optional[str]:
    """Return the name of the first active team member that isn't us."""
    config = _read_json(_config_path(team), {})
    for m in config.get("members", []):
        if m.get("name") != my_name and m.get("isActive", True):
            return m["name"]
    for m in config.get("members", []):
        if m.get("name") != my_name:
            return m["name"]
    return None


# ---------------------------------------------------------------------------
# Inbox I/O
# ---------------------------------------------------------------------------

def _drain_inbox(team: str, name: str) -> List[Dict[str, Any]]:
    """Atomically read and clear the inbox, returning all messages."""
    ib = _inbox_path(team, name)
    with FileLock(ib):
        if not ib.exists():
            _write_json_atomic(ib, [])
        messages = _read_json(ib, [])
        if messages:
            _write_json_atomic(ib, [])
    return messages if isinstance(messages, list) else []


def _post_to_inbox(team: str, recipient: str, message: Dict[str, Any]) -> None:
    """Append a message to *recipient*'s inbox."""
    ib = _inbox_path(team, recipient)
    with FileLock(ib):
        messages = _read_json(ib, [])
        if not isinstance(messages, list):
            messages = []
        messages.append(message)
        _write_json_atomic(ib, messages)


# ---------------------------------------------------------------------------
# Task scanning & updates
# ---------------------------------------------------------------------------

def _scan_pending_tasks(team: str, owner: str) -> List[Dict[str, Any]]:
    """Return pending, unblocked tasks assigned to *owner*, sorted by id."""
    tdir = _tasks_dir(team)
    if not tdir.exists():
        return []

    result: list[Dict[str, Any]] = []
    for fpath in sorted(tdir.glob("*.json")):
        with FileLock(fpath):
            task = _read_json(fpath)
        if not isinstance(task, dict):
            continue
        if task.get("owner") != owner:
            continue
        if task.get("status") != "pending":
            continue

        blocked_by = task.get("blockedBy", [])
        if blocked_by:
            all_resolved = True
            for bid in blocked_by:
                blocker_path = tdir / f"{bid}.json"
                with FileLock(blocker_path):
                    blocker = _read_json(blocker_path)
                if blocker and blocker.get("status") != "completed":
                    all_resolved = False
                    break
            if not all_resolved:
                continue

        result.append(task)

    return result


def _update_task(team: str, task_id: str, updates: Dict[str, Any]) -> None:
    """Merge *updates* into the task file."""
    task_path = _tasks_dir(team) / f"{task_id}.json"
    with FileLock(task_path):
        task = _read_json(task_path, {})
        if not task:
            raise FileNotFoundError(f"Task {task_id} does not exist at {task_path}")
        task.update(updates)
        _write_json_atomic(task_path, task)


# ---------------------------------------------------------------------------
# Model selection heuristic
# ---------------------------------------------------------------------------

def _select_model(subject: str, description: str, default_model: Optional[str]) -> Optional[str]:
    """Return a specific model for complex tasks, else *default_model*.

    For complex tasks (detected by keywords), we use opus.
    For simple tasks, we use the default (None = claude's default, usually sonnet).
    """
    text = f"{subject} {description}".lower()
    for kw in DEEP_KEYWORDS:
        if kw in text:
            return "claude-opus-4-6"
    return default_model


# ---------------------------------------------------------------------------
# Prompt builder
# ---------------------------------------------------------------------------

def _build_prompt(subject: str, description: str, inbox_context: str = "") -> str:
    parts = [f"# TASK: {subject}"]
    if description:
        parts.append(f"\n{description}")
    if inbox_context:
        parts.append(f"\n## Additional Context\n{inbox_context}")
    parts.append(
        "\n# Output (STRICT)\n"
        "When you are completely finished, output ONLY a JSON object on its last line:\n"
        '{"goal_met": true/false, "summary": "what you did"}\n'
        "This must be the very last thing you output."
    )
    return "\n".join(parts)


# ---------------------------------------------------------------------------
# Claude execution
# ---------------------------------------------------------------------------

def _extract_structured_result(stdout: str) -> Dict[str, Any]:
    """Try to extract {goal_met, summary} JSON from Claude's output."""
    # Try parsing the entire output as JSON first
    try:
        parsed = json.loads(stdout.strip())
        if isinstance(parsed, dict) and "goal_met" in parsed:
            return parsed
    except (json.JSONDecodeError, TypeError):
        pass

    # Try to find JSON in the output (last JSON object wins)
    result = None
    for line in reversed(stdout.strip().splitlines()):
        line = line.strip()
        if line.startswith("{") and line.endswith("}"):
            try:
                parsed = json.loads(line)
                if isinstance(parsed, dict) and "goal_met" in parsed:
                    result = parsed
                    break
            except json.JSONDecodeError:
                continue

    if result:
        return result

    # Try to extract from --output-format json response
    try:
        parsed = json.loads(stdout.strip())
        if isinstance(parsed, dict):
            # Claude --output-format json wraps in {"result": "..."}
            text = parsed.get("result", "") or parsed.get("text", "") or str(parsed)
            for line in reversed(text.strip().splitlines()):
                line = line.strip()
                if line.startswith("{") and line.endswith("}"):
                    try:
                        inner = json.loads(line)
                        if isinstance(inner, dict) and "goal_met" in inner:
                            return inner
                    except json.JSONDecodeError:
                        continue
    except (json.JSONDecodeError, TypeError):
        pass

    # Fallback: couldn't extract structured result
    return {
        "goal_met": False,
        "summary": f"Could not extract structured result. Raw output (last 500 chars): {stdout[-500:]}",
    }


def _run_claude_task(
    project_dir: str,
    prompt: str,
    timeout: int,
    model: Optional[str] = None,
) -> Dict[str, Any]:
    """Run a Claude Code task via `claude -p` and return structured result."""
    cmd = ["claude", "-p", prompt, "--output-format", "json"]
    if model:
        cmd.extend(["--model", model])

    try:
        proc = subprocess.Popen(
            cmd,
            cwd=project_dir,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )
        try:
            stdout, stderr = proc.communicate(timeout=timeout)
        except subprocess.TimeoutExpired:
            proc.kill()
            proc.wait()
            return {"goal_met": False, "summary": f"claude -p timed out after {timeout}s"}

        if proc.returncode != 0 and not stdout.strip():
            return {
                "goal_met": False,
                "summary": f"claude -p failed (rc={proc.returncode}): {stderr.strip()[:300]}",
            }

        return _extract_structured_result(stdout)

    except FileNotFoundError:
        return {"goal_met": False, "summary": "claude CLI not found. Install: npm install -g @anthropic-ai/claude-code"}
    except Exception as exc:
        return {"goal_met": False, "summary": f"claude -p error: {exc}"}


# ---------------------------------------------------------------------------
# Result reporting
# ---------------------------------------------------------------------------

def _report_result(
    team: str,
    my_name: str,
    task_id: str,
    task_subject: str,
    result: Dict[str, Any],
) -> None:
    """Update the task status and post a summary to the leader's inbox."""
    goal_met = result.get("goal_met", False)
    summary = result.get("summary", "No summary")

    if goal_met:
        _update_task(team, task_id, {"status": "completed"})
    else:
        _update_task(team, task_id, {
            "status": "failed",
            "error": summary[:500],
            "failed_at": _now_iso(),
        })

    tag = "COMPLETED" if goal_met else "FAILED"
    text_lines = [f"[claude-bridge] Task #{task_id} {tag}"]
    text_lines.append(f"Summary: {summary}")

    short_summary = summary[:60]
    msg = {
        "from": my_name,
        "text": "\n".join(text_lines),
        "summary": f"Task #{task_id} {'done' if goal_met else 'failed'}: {short_summary}",
        "timestamp": _now_iso(),
        "read": False,
        "color": "blue",
    }

    leader = _find_leader(team, my_name)
    if leader:
        _post_to_inbox(team, leader, msg)
    else:
        _log("No leader found; writing result to fallback file")
        fallback = _tasks_dir(team) / f"{task_id}_result.json"
        _write_json_atomic(fallback, msg)


# ---------------------------------------------------------------------------
# Shutdown detection
# ---------------------------------------------------------------------------

def _is_shutdown_request(msg: Dict[str, Any]) -> Tuple[bool, Optional[str]]:
    """Check if an inbox message is a shutdown request."""
    text = msg.get("text", "")
    try:
        parsed = json.loads(text)
        if isinstance(parsed, dict) and parsed.get("type") == "shutdown_request":
            return True, parsed.get("requestId") or parsed.get("request_id")
    except (json.JSONDecodeError, TypeError):
        pass
    return False, None


# ---------------------------------------------------------------------------
# Logging
# ---------------------------------------------------------------------------

def _log(msg: str) -> None:
    ts = datetime.now().strftime("%H:%M:%S")
    print(f"[claude-bridge {ts}] {msg}", flush=True)


# ---------------------------------------------------------------------------
# Main loop
# ---------------------------------------------------------------------------

def _main_loop(
    team: str,
    name: str,
    project_dir: str,
    model: Optional[str],
    poll_interval: float,
    task_timeout: int,
) -> None:
    _log(f"Started  team={team}  name={name}  project={project_dir}  model={model or 'default'}")
    _log(f"Poll every {poll_interval}s, task timeout {task_timeout}s")
    _log(f"Config   {_config_path(team)}")
    _log(f"Inbox    {_inbox_path(team, name)}")
    _log(f"Tasks    {_tasks_dir(team)}/")
    _log("Waiting for tasks...")

    running = True

    def _on_signal(signum: int, _frame: Any) -> None:
        nonlocal running
        _log(f"Signal {signum} received, shutting down")
        running = False

    signal.signal(signal.SIGINT, _on_signal)
    signal.signal(signal.SIGTERM, _on_signal)

    while running:
        try:
            # ---- 1. Drain inbox ----
            messages = _drain_inbox(team, name)
            inbox_context_parts: list[str] = []

            for msg in messages:
                is_shutdown, req_id = _is_shutdown_request(msg)
                if is_shutdown:
                    _log(f"Shutdown request from {msg.get('from', '?')}")
                    deregister(team, name)
                    return

                sender = msg.get("from", "unknown")
                inbox_context_parts.append(
                    f"[Message from {sender}]: {msg.get('text', '')}"
                )

            inbox_context = "\n".join(inbox_context_parts).strip()

            # ---- 2a. Watchdog: reset abandoned in_progress tasks ----
            abandon_limit = 2 * task_timeout
            tdir = _tasks_dir(team)
            if tdir.exists():
                for fpath in tdir.glob("*.json"):
                    with FileLock(fpath):
                        t = _read_json(fpath)
                    if (
                        isinstance(t, dict)
                        and t.get("owner") == name
                        and t.get("status") == "in_progress"
                        and t.get("started_at")
                    ):
                        try:
                            started = datetime.fromisoformat(
                                t["started_at"].replace("Z", "+00:00")
                            )
                            elapsed = (
                                datetime.now(timezone.utc) - started
                            ).total_seconds()
                            if elapsed > abandon_limit:
                                _log(f"Watchdog: resetting abandoned task {t.get('id')}")
                                tid = str(t.get("id"))
                                _update_task(team, tid, {
                                    "status": "pending",
                                    "started_at": None,
                                })
                        except (ValueError, TypeError):
                            pass

            # ---- 2b. Scan for pending tasks ----
            tasks = _scan_pending_tasks(team, name)
            if not tasks:
                time.sleep(poll_interval)
                continue

            # ---- 3. Pick first pending task ----
            task = tasks[0]
            task_id = str(task.get("id", "?"))
            subject = task.get("subject", "(no subject)")
            description = task.get("description", "")

            _log(f">>> Task #{task_id}: {subject}")

            # ---- 4. Mark in_progress ----
            _update_task(team, task_id, {
                "status": "in_progress",
                "started_at": _now_iso(),
            })

            # ---- 5. Build prompt & select model ----
            effective_model = _select_model(subject, description, model)
            prompt = _build_prompt(subject, description, inbox_context)

            _log(f"    model={effective_model or 'default'}")

            # ---- 6. Run Claude ----
            result = _run_claude_task(project_dir, prompt, task_timeout,
                                      model=effective_model)

            goal = result.get("goal_met")
            _log(f"    result: goal_met={goal}")

            # ---- 7. Report result ----
            _report_result(team, name, task_id, subject, result)

        except (IOError, json.JSONDecodeError, subprocess.CalledProcessError,
                subprocess.TimeoutExpired, FileNotFoundError) as exc:
            _log(f"ERROR in main loop: {exc}")
            time.sleep(poll_interval)

    # Graceful exit
    deregister(team, name)
    _log("Stopped.")


# ---------------------------------------------------------------------------
# CLI commands
# ---------------------------------------------------------------------------

def _wait_for_team(team: str, poll_interval: float) -> None:
    """Block until the team config file exists."""
    cfg = _config_path(team)
    while not cfg.exists():
        _log(f"Waiting for team '{team}' to be created...")
        time.sleep(poll_interval)
    time.sleep(1)
    _log(f"Team '{team}' detected")


def cmd_join(args: argparse.Namespace) -> int:
    team: str = args.team
    name: str = args.name
    project_dir: str = args.project

    proj_path = Path(project_dir).expanduser().resolve()
    cwd = str(proj_path) if proj_path.is_dir() else os.getcwd()

    _wait_for_team(team, args.poll_interval)

    _log(f"Joining team={team} as name={name}")
    register(team, name, cwd)
    _log("Registered")

    _main_loop(
        team=team,
        name=name,
        project_dir=cwd,
        model=args.model,
        poll_interval=args.poll_interval,
        task_timeout=args.task_timeout,
    )
    return 0


def cmd_leave(args: argparse.Namespace) -> int:
    team: str = args.team
    name: str = args.name

    _log(f"Leaving team={team} as name={name}")
    deregister(team, name)
    _log("Deregistered (isActive=false)")
    return 0


# ---------------------------------------------------------------------------
# Argument parser
# ---------------------------------------------------------------------------

def _build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(
        prog="claude-bridge",
        description="Claude Code CLI as a Claude Code team member. "
                    "Polls the team task list and executes tasks via claude -p.",
    )
    sub = p.add_subparsers(dest="cmd", required=True)

    sp = sub.add_parser(
        "join",
        help="Join a Claude Code team and start processing tasks.",
    )
    sp.add_argument("--team", required=True, help="Team name")
    sp.add_argument("--name", default="claude-worker",
                    help="Worker name in team (default: claude-worker)")
    sp.add_argument("--project", required=True,
                    help="Project directory path")
    sp.add_argument("--model", default=DEFAULT_MODEL,
                    help="Default Claude model (default: claude's default)")
    sp.add_argument("--poll-interval", type=float, default=DEFAULT_POLL_INTERVAL,
                    help=f"Seconds between polls (default: {DEFAULT_POLL_INTERVAL})")
    sp.add_argument("--task-timeout", type=int, default=DEFAULT_TASK_TIMEOUT,
                    help=f"Max seconds per task (default: {DEFAULT_TASK_TIMEOUT})")
    sp.set_defaults(func=cmd_join)

    sp = sub.add_parser(
        "leave",
        help="Gracefully leave a team (sets isActive=false).",
    )
    sp.add_argument("--team", required=True, help="Team name")
    sp.add_argument("--name", default="claude-worker",
                    help="Worker name (default: claude-worker)")
    sp.set_defaults(func=cmd_leave)

    return p


# ---------------------------------------------------------------------------
# Entry point
# ---------------------------------------------------------------------------

def main() -> int:
    parser = _build_parser()
    args = parser.parse_args()
    return int(args.func(args))


if __name__ == "__main__":
    raise SystemExit(main())
