#!/usr/bin/env python3
"""
agentctl: tiny tmux + Codex CLI orchestration helper.

Designed for:
- spawning many parallel `codex exec` runs in tmux windows (per project)
- collecting structured outputs via --output-schema / -o
- emitting a lightweight "done" notification back to a chosen tmux target
- (optional) resuming a non-interactive session via `codex exec resume <SESSION_ID>`

No external deps. Python 3.9+ recommended.
"""
from __future__ import annotations

# Disable output buffering so pipes (| head, etc.) don't hang.
import io as _io
import sys as _sys_early
if not _sys_early.stdout.isatty():
    _sys_early.stdout = _io.TextIOWrapper(_sys_early.stdout.buffer, write_through=True)
    _sys_early.stderr = _io.TextIOWrapper(_sys_early.stderr.buffer, write_through=True)

import argparse
import datetime as _dt
import json
import os
import random
import re
import shlex
import string
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, Optional, Tuple


def _now_iso() -> str:
    return _dt.datetime.now().astimezone().isoformat(timespec="seconds")


def _short_rand(n: int = 6) -> str:
    alphabet = string.ascii_lowercase + string.digits
    return "".join(random.choice(alphabet) for _ in range(n))


def _default_home() -> Path:
    env = os.environ.get("AI_ORCH_HOME")
    if env:
        return Path(env).expanduser()
    # Default: .ai-orch next to the project root (parent of bin/)
    return Path(__file__).resolve().parent.parent / ".ai-orch"


def _paths(home: Path) -> Dict[str, Path]:
    return {
        "home": home,
        "runs": home / "runs",
        "projects": home / "projects.json",
        "config": home / "config.json",
        "schema": home / "codex_output_schema.json",
        "notify_log": home / "notify.log",
    }


def _load_json(path: Path, default: Any) -> Any:
    if not path.exists():
        return default
    return json.loads(path.read_text(encoding="utf-8"))


def _save_json(path: Path, obj: Any) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(obj, ensure_ascii=False, indent=2) + "\n", encoding="utf-8")


def _have_tmux() -> bool:
    try:
        subprocess.run(["tmux", "-V"], check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return True
    except Exception:
        return False


def _tmux_display_message(target: str, msg: str) -> None:
    if not _have_tmux():
        return
    try:
        subprocess.run(["tmux", "display-message", "-t", target, msg], check=False)
    except Exception:
        pass


def _tmux_send_keys(target: str, text: str, *, enter: bool = False) -> None:
    if not _have_tmux():
        return
    try:
        subprocess.run(["tmux", "send-keys", "-t", target, text], check=False)
        if enter:
            subprocess.run(["tmux", "send-keys", "-t", target, "Enter"], check=False)
    except Exception:
        pass


def _current_tmux_session() -> Optional[str]:
    if not _have_tmux():
        return None
    try:
        out = subprocess.check_output(["tmux", "display-message", "-p", "#S"], text=True).strip()
        return out or None
    except Exception:
        return None


def _safe_tmux_name(s: str, max_len: int = 40) -> str:
    s = re.sub(r"[^a-zA-Z0-9._-]+", "-", s).strip("-")
    if not s:
        s = "run"
    return s[:max_len]


def _read_prompt(prompt_file: str) -> str:
    if prompt_file == "-":
        return sys.stdin.read()
    return Path(prompt_file).expanduser().read_text(encoding="utf-8")


def _ensure_init(home: Path) -> Dict[str, Path]:
    p = _paths(home)
    p["home"].mkdir(parents=True, exist_ok=True)
    p["runs"].mkdir(parents=True, exist_ok=True)

    if not p["config"].exists():
        _save_json(p["config"], {})
    if not p["projects"].exists():
        _save_json(p["projects"], {"projects": {}})
    if not p["schema"].exists():
        _save_json(
            p["schema"],
            {
                "type": "object",
                "properties": {
                    "goal_met": {"type": "boolean"},
                    "summary": {"type": "string"},
                    "followup_prompt": {"type": "string"},
                    "notes": {"type": "string"},
                },
                "required": ["goal_met", "summary"],
                "additionalProperties": True,
            },
        )
    if not p["notify_log"].exists():
        p["notify_log"].write_text("", encoding="utf-8")

    return p


def cmd_init(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)

    session = _current_tmux_session() or os.environ.get("AI_TMUX_SESSION") or "ai"
    cfg = _load_json(p["config"], {})
    cfg.setdefault("tmux_session", session)
    cfg.setdefault("tmux_notify_target", f"{session}:0")  # window 0
    # If you want true "wake-up" into your Claude/Opus pane, set this to a pane id like "ai:0.0".
    cfg.setdefault("tmux_sendkeys_target", "")
    _save_json(p["config"], cfg)

    print("✅ Initialized agentctl workspace:")
    print(f"  Home:    {p['home']}")
    print(f"  Runs:    {p['runs']}")
    print(f"  Config:  {p['config']}")
    print(f"  Projects:{p['projects']}")
    print(f"  Schema:  {p['schema']}")
    print()
    print("Next:")
    print("  1) Add projects: agentctl add-project <name> <path> [--default-profile spark]")
    print("  2) Ensure Codex profiles exist in ~/.codex/config.toml (see answer template).")
    return 0


def cmd_add_project(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)
    data = _load_json(p["projects"], {"projects": {}})

    proj_path = Path(args.path).expanduser().resolve()
    if not proj_path.exists():
        print(f"❌ path does not exist: {proj_path}", file=sys.stderr)
        return 2

    data.setdefault("projects", {})
    data["projects"][args.name] = {"path": str(proj_path), "default_profile": args.default_profile}
    _save_json(p["projects"], data)
    print(f"✅ added project '{args.name}' -> {proj_path}")
    return 0


def _get_project(name: str, projects_path: Path) -> Optional[Dict[str, Any]]:
    data = _load_json(projects_path, {"projects": {}})
    return data.get("projects", {}).get(name)


def _resolve_project(args: argparse.Namespace, projects_path: Path) -> Tuple[str, Path, Optional[str]]:
    """Resolve project name, directory, and default profile.

    If --project is given and registered, use it.
    If --project is given but not registered, treat it as a path.
    If --project is not given, use cwd.

    Returns (proj_name, proj_dir, default_profile).
    """
    project_arg = getattr(args, "project", None)

    if project_arg:
        # Try registered project first
        proj = _get_project(project_arg, projects_path)
        if proj:
            return project_arg, Path(proj["path"]), proj.get("default_profile")
        # Treat as path
        proj_dir = Path(project_arg).expanduser().resolve()
        if proj_dir.is_dir():
            return proj_dir.name, proj_dir, None
        print(f"Error: '{project_arg}' is not a registered project or valid directory.", file=sys.stderr)
        sys.exit(2)

    # Default: current working directory
    proj_dir = Path.cwd().resolve()
    return proj_dir.name, proj_dir, None


def _write_run_meta(run_dir: Path, meta: Dict[str, Any]) -> None:
    _save_json(run_dir / "meta.json", meta)


def _new_run_id() -> str:
    return f"{_dt.datetime.now().strftime('%Y%m%d-%H%M%S')}-{_short_rand(4)}"


def _build_codex_command(
    *,
    mode: str,
    proj_dir: Path,
    profile: str,
    prompt_file: Path,
    schema_path: Optional[Path],
    last_file: Optional[Path],
    ephemeral: bool,
    full_auto: bool,
    sandbox: Optional[str],
    ask_for_approval: Optional[str],
    model: Optional[str],
    json_events: bool,
    skip_git_repo_check: bool,
    headless: bool,
    resume_session_id: Optional[str] = None,
) -> str:
    """
    Returns a shell-ready string.

    headless=True  -> codex exec (no UI, for scripting)
    headless=False -> codex (full TUI, user can watch)
    """
    if headless:
        parts: list[str] = ["codex", "exec"]
        if mode == "resume":
            parts.append("resume")
            if resume_session_id:
                parts.append(shlex.quote(resume_session_id))
    else:
        parts = ["codex"]

    parts += ["-C", shlex.quote(str(proj_dir)), "--profile", shlex.quote(profile)]

    if headless and ephemeral:
        parts.append("--ephemeral")
    if sandbox:
        if full_auto:
            parts.append("--full-auto")
        if headless:
            parts += ["--sandbox", shlex.quote(sandbox)]
        else:
            parts += ["-c", f"sandbox_mode={shlex.quote(sandbox)}"]
    elif headless:
        # No sandbox specified: bypass sandbox entirely for full network access (SOCKS, etc.)
        # --dangerously-bypass-approvals-and-sandbox already implies --full-auto
        parts.append("--dangerously-bypass-approvals-and-sandbox")
    elif full_auto:
        parts.append("--full-auto")
    if ask_for_approval:
        if headless:
            parts += ["--ask-for-approval", shlex.quote(ask_for_approval)]
        else:
            parts += ["-c", f"approval_policy={shlex.quote(ask_for_approval)}"]
    if model:
        parts += ["--model", shlex.quote(model)]
    if headless and json_events:
        parts.append("--json")
    if headless and skip_git_repo_check:
        parts.append("--skip-git-repo-check")

    if headless:
        # exec mode: structured output + stdin prompt
        if schema_path:
            parts += ["--output-schema", shlex.quote(str(schema_path))]
        if last_file:
            parts += ["-o", shlex.quote(str(last_file))]
        parts.append("-")  # read prompt from stdin
    else:
        # interactive mode: prompt as positional argument
        prompt_text = prompt_file.read_text(encoding="utf-8").strip()
        parts.append(shlex.quote(prompt_text))

    return " ".join(parts)


def _run_redirects(*, headless: bool, json_events: bool, events_file: Path, stderr_file: Path, prompt_file: Path) -> str:
    """Shell redirections for the codex command."""
    if headless:
        if json_events:
            return f'< "{prompt_file}" > "{events_file}" 2> "{stderr_file}"'
        return f'< "{prompt_file}" 2> "{stderr_file}"'
    # Interactive mode: no stdin redirect (prompt is a positional arg), stderr to log
    return f'2> "{stderr_file}"'


def _spawn_tmux_pane(
    *,
    tmux_target: str,
    cwd: Path,
    script_path: Path,
    main_pane_width: str = "50%",
) -> None:
    """Spawn a new pane on the right side of the orchestrator window.

    Uses main-vertical layout: pane 0 (orchestrator) stays on the left,
    all agent panes stack vertically on the right.
    """
    if not _have_tmux():
        raise RuntimeError("tmux not found")
    # Split horizontally from the target window — new pane appears on the right
    subprocess.run(
        ["tmux", "split-window", "-h", "-t", tmux_target,
         "-c", str(cwd), "bash", str(script_path)],
        check=True,
    )
    # Keep finished panes open for inspection
    subprocess.run(["tmux", "set-option", "-t", tmux_target, "remain-on-exit", "on"], check=False)
    # Set main pane width (orchestrator)
    subprocess.run(["tmux", "set-option", "-t", tmux_target, "main-pane-width", main_pane_width], check=False)
    # Rebalance: main-vertical = pane 0 left, rest stacked right
    subprocess.run(["tmux", "select-layout", "-t", tmux_target, "main-vertical"], check=False)
    # Return focus to the orchestrator pane (pane 0)
    subprocess.run(["tmux", "select-pane", "-t", f"{tmux_target}.0"], check=False)


def _start_common(
    *,
    args: argparse.Namespace,
    run_id: str,
    run_dir: Path,
    proj_name: str,
    proj_dir: Path,
    profile: str,
    codex_cmd: str,
    title: str,
    parent_run_id: Optional[str] = None,
    resume_session_id: Optional[str] = None,
) -> None:
    prompt_path = run_dir / "prompt.md"
    if not prompt_path.exists():
        prompt = _read_prompt(args.prompt_file)
        prompt_path.write_text(prompt, encoding="utf-8")

    meta = {
        "run_id": run_id,
        "title": title or "",
        "project": proj_name,
        "project_dir": str(proj_dir),
        "profile": profile,
        "created_at": _now_iso(),
        "status": "running",
        "mode": "exec" if resume_session_id is None else "resume",
        "parent_run_id": parent_run_id,
        "thread_id": resume_session_id,  # filled from events for fresh runs; for resume we already know it
        "exit_code": None,
        "ended_at": None,
        "goal_met": None,
        "summary": None,
    }
    _write_run_meta(run_dir, meta)

    events_file = run_dir / "events.jsonl"
    stderr_file = run_dir / "stderr.log"
    prompt_file = run_dir / "prompt.md"

    run_sh = run_dir / "run.sh"
    run_sh.write_text(
        "\n".join(
            [
                "#!/usr/bin/env bash",
                "set -u",
                f'RUN_ID="{run_id}"',
                f'PROJECT_DIR="{str(proj_dir)}"',
                f'RUN_DIR="{str(run_dir)}"',
                "",
                'echo "[agentctl] run=$RUN_ID project=$PROJECT_DIR profile=' + profile + '"',
                "cd \"$PROJECT_DIR\"",
                "",
                "# Watchdog: auto-kill Codex after result.json appears",
                'RESULT_FILE="$RUN_DIR/result.json"',
                'SCRIPT_PID=$$',
                '(',
                '  while true; do',
                '    sleep 5',
                '    if [ -f "$RESULT_FILE" ]; then',
                '      sleep 3  # grace period',
                '      pkill -P "$SCRIPT_PID" -f codex 2>/dev/null || true',
                '      break',
                '    fi',
                '  done',
                ') &',
                'WATCHDOG_PID=$!',
                "",
                "set +e",
                f'{codex_cmd} {_run_redirects(headless=args.headless, json_events=args.json_events, events_file=events_file, stderr_file=stderr_file, prompt_file=prompt_file)}',
                "EC=$?",
                'kill $WATCHDOG_PID 2>/dev/null; wait $WATCHDOG_PID 2>/dev/null',
                "set -e",
                "",
                f'python3 "{str(Path(__file__).resolve())}" _on_finish --run-id "$RUN_ID" --exit-code "$EC"',
                "",
                'echo ""',
                'echo "[agentctl] done run=$RUN_ID exit=$EC"',
                f'echo "[agentctl] artifacts: {str(run_dir)}"',
                '# Auto-close pane when done',
                'tmux kill-pane -t "$TMUX_PANE" 2>/dev/null || exit 0',
                "",
            ]
        )
        + "\n",
        encoding="utf-8",
    )
    run_sh.chmod(0o755)

    tmux_session = args.tmux_session
    # Target the orchestrator's window (default: window where orchestrator runs)
    tmux_target = f"{tmux_session}:{args.tmux_window}" if getattr(args, "tmux_window", None) else tmux_session
    _spawn_tmux_pane(tmux_target=tmux_target, cwd=proj_dir, script_path=run_sh)


def cmd_start(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)
    cfg = _load_json(p["config"], {})
    proj_name, proj_dir, default_profile = _resolve_project(args, p["projects"])

    profile = args.profile or default_profile or "spark"
    run_id = args.run_id or _new_run_id()
    run_dir = p["runs"] / run_id
    run_dir.mkdir(parents=True, exist_ok=False)

    tmux_session = args.tmux_session or cfg.get("tmux_session") or _current_tmux_session() or "ai"
    args.tmux_session = tmux_session

    schema_path = Path(args.output_schema).expanduser() if args.output_schema else p["schema"]
    last_file = run_dir / "last_message.json"

    prompt_file_path = run_dir / "prompt.md"
    result_file = run_dir / "result.json"
    # Write prompt early so _build_codex_command can read it in non-headless mode
    prompt_text_raw = _read_prompt(args.prompt_file)
    if not args.headless:
        # Inject result-file instruction so interactive Codex writes structured output
        result_instruction = (
            f"\n\n# RESULT FILE (mandatory)\n"
            f"When you are completely done, you MUST write your final result as a JSON file:\n"
            f"Path: {result_file}\n"
            f"Schema: {{\"goal_met\": bool, \"summary\": string, \"followup_prompt\": string, \"notes\": string}}\n"
            f"Use a shell command like: cat > {result_file} << 'RESULT_EOF'\n"
            f"{{...your JSON...}}\n"
            f"RESULT_EOF\n"
            f"This is your LAST action before finishing."
        )
        prompt_text_raw = prompt_text_raw.rstrip() + result_instruction
    prompt_file_path.write_text(prompt_text_raw, encoding="utf-8")

    codex_cmd = _build_codex_command(
        mode="exec",
        proj_dir=proj_dir,
        profile=profile,
        prompt_file=prompt_file_path,
        schema_path=schema_path if args.headless else None,
        last_file=last_file if args.headless else None,
        ephemeral=args.ephemeral,
        full_auto=args.full_auto,
        sandbox=args.sandbox,
        ask_for_approval=args.ask_for_approval,
        model=args.model,
        json_events=args.json_events,
        skip_git_repo_check=args.skip_git_repo_check,
        headless=args.headless,
    )

    _start_common(
        args=args,
        run_id=run_id,
        run_dir=run_dir,
        proj_name=proj_name,
        proj_dir=proj_dir,
        profile=profile,
        codex_cmd=codex_cmd,
        title=args.title,
    )

    notify_target = cfg.get("tmux_notify_target", f"{tmux_session}:0")
    _tmux_display_message(notify_target, f"▶️ Codex started: {run_id} ({proj_name}, {profile})")
    print(run_id)
    return 0


def cmd_resume(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)
    cfg = _load_json(p["config"], {})

    parent_run_id = args.parent_run_id
    parent_dir = p["runs"] / parent_run_id
    parent_meta_path = parent_dir / "meta.json"
    if not parent_meta_path.exists():
        print(f"❌ unknown parent run_id: {parent_run_id}", file=sys.stderr)
        return 2
    parent_meta = _load_json(parent_meta_path, {})
    session_id = parent_meta.get("thread_id")
    if not session_id:
        print("❌ parent run has no thread_id (maybe it was --ephemeral or events weren't captured).", file=sys.stderr)
        return 2

    proj_name = parent_meta.get("project")
    proj_dir = Path(parent_meta.get("project_dir", "")).expanduser()
    if not proj_name or not proj_dir.exists():
        print("❌ could not resolve project from parent run.", file=sys.stderr)
        return 2

    profile = args.profile or parent_meta.get("profile") or "spark"
    run_id = args.run_id or _new_run_id()
    run_dir = p["runs"] / run_id
    run_dir.mkdir(parents=True, exist_ok=False)

    tmux_session = args.tmux_session or cfg.get("tmux_session") or _current_tmux_session() or "ai"
    args.tmux_session = tmux_session

    schema_path = Path(args.output_schema).expanduser() if args.output_schema else p["schema"]
    last_file = run_dir / "last_message.json"

    prompt_file_path = run_dir / "prompt.md"
    result_file = run_dir / "result.json"
    # Write prompt early so _build_codex_command can read it in non-headless mode
    prompt_text_raw = _read_prompt(args.prompt_file)
    if not args.headless:
        result_instruction = (
            f"\n\n# RESULT FILE (mandatory)\n"
            f"When you are completely done, you MUST write your final result as a JSON file:\n"
            f"Path: {result_file}\n"
            f"Schema: {{\"goal_met\": bool, \"summary\": string, \"followup_prompt\": string, \"notes\": string}}\n"
            f"Use a shell command like: cat > {result_file} << 'RESULT_EOF'\n"
            f"{{...your JSON...}}\n"
            f"RESULT_EOF\n"
            f"This is your LAST action before finishing."
        )
        prompt_text_raw = prompt_text_raw.rstrip() + result_instruction
    prompt_file_path.write_text(prompt_text_raw, encoding="utf-8")

    codex_cmd = _build_codex_command(
        mode="resume",
        resume_session_id=str(session_id),
        proj_dir=proj_dir,
        profile=profile,
        prompt_file=prompt_file_path,
        schema_path=schema_path if args.headless else None,
        last_file=last_file if args.headless else None,
        ephemeral=args.ephemeral,
        full_auto=args.full_auto,
        sandbox=args.sandbox,
        ask_for_approval=args.ask_for_approval,
        model=args.model,
        json_events=args.json_events,
        skip_git_repo_check=args.skip_git_repo_check,
        headless=args.headless,
    )

    _start_common(
        args=args,
        run_id=run_id,
        run_dir=run_dir,
        proj_name=str(proj_name),
        proj_dir=proj_dir,
        profile=profile,
        codex_cmd=codex_cmd,
        title=args.title,
        parent_run_id=parent_run_id,
        resume_session_id=str(session_id),
    )

    notify_target = cfg.get("tmux_notify_target", f"{tmux_session}:0")
    _tmux_display_message(notify_target, f"↩️ Codex resumed: {run_id} (parent={parent_run_id})")
    print(run_id)
    return 0


def _extract_thread_id(events_path: Path) -> Optional[str]:
    if not events_path.exists():
        return None
    try:
        with events_path.open("r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                try:
                    obj = json.loads(line)
                except json.JSONDecodeError:
                    continue
                if obj.get("type") == "thread.started":
                    tid = obj.get("thread_id") or obj.get("thread-id") or obj.get("threadId")
                    if isinstance(tid, str) and tid:
                        return tid
                if obj.get("type") == "thread.started" and isinstance(obj.get("thread"), dict):
                    tid = obj["thread"].get("id")
                    if isinstance(tid, str) and tid:
                        return tid
    except Exception:
        return None
    return None


def _read_last_message(last_path: Path) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
    if not last_path.exists():
        return None, None
    raw = last_path.read_text(encoding="utf-8").strip()
    if not raw:
        return None, None
    try:
        return json.loads(raw), raw
    except json.JSONDecodeError:
        return None, raw


def _git_diff_stat(repo: Path) -> Optional[str]:
    try:
        out = subprocess.check_output(["git", "-C", str(repo), "diff", "--stat"], text=True, stderr=subprocess.DEVNULL).strip()
        return out or ""
    except Exception:
        return None


def cmd_on_finish(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)
    cfg = _load_json(p["config"], {})

    run_id = args.run_id
    run_dir = p["runs"] / run_id
    meta_path = run_dir / "meta.json"
    if not meta_path.exists():
        print(f"[agentctl] _on_finish: meta not found for run_id={run_id}", file=sys.stderr)
        return 2

    meta = _load_json(meta_path, {})
    meta["status"] = "finished"
    meta["exit_code"] = int(args.exit_code)
    meta["ended_at"] = _now_iso()

    if not meta.get("thread_id"):
        thread_id = _extract_thread_id(run_dir / "events.jsonl")
        if thread_id:
            meta["thread_id"] = thread_id

    parsed, raw = _read_last_message(run_dir / "last_message.json")
    if parsed is None:
        # Fallback: interactive mode writes result.json via prompt instruction
        parsed, raw = _read_last_message(run_dir / "result.json")
    if parsed is not None:
        meta["goal_met"] = parsed.get("goal_met")
        meta["summary"] = parsed.get("summary")
        meta["last_message"] = parsed
    else:
        meta["last_message_raw"] = raw

    proj_dir = Path(meta.get("project_dir", "")).expanduser()
    diff_stat = _git_diff_stat(proj_dir) if proj_dir else None
    if diff_stat is not None:
        meta["git_diff_stat"] = diff_stat

    _save_json(meta_path, meta)

    summary = meta.get("summary")
    goal_met = meta.get("goal_met")
    emoji = "✅" if goal_met is True and meta.get("exit_code") == 0 else ("⚠️" if meta.get("exit_code") == 0 else "❌")
    line = f"[{_dt.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {emoji} done {run_id} proj={meta.get('project')} profile={meta.get('profile')} goal_met={goal_met} exit={meta.get('exit_code')}"
    if summary:
        line += f" — {summary}"
    line += "\n"

    p["notify_log"].write_text(p["notify_log"].read_text(encoding="utf-8") + line, encoding="utf-8")

    tmux_target = cfg.get("tmux_notify_target") or f"{cfg.get('tmux_session','ai')}:0"
    _tmux_display_message(tmux_target, line.strip())

    sendkeys_target = (cfg.get("tmux_sendkeys_target") or "").strip()
    if sendkeys_target:
        msg = f"[AI_ORCH DONE run_id={run_id} goal_met={goal_met} exit={meta.get('exit_code')}]"
        _tmux_send_keys(sendkeys_target, msg, enter=True)

    return 0


def cmd_list(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)
    runs_dir = p["runs"]

    runs = sorted([d for d in runs_dir.iterdir() if d.is_dir()], key=lambda d: d.name, reverse=True)
    runs = runs[: args.limit]

    for d in runs:
        meta_path = d / "meta.json"
        if not meta_path.exists():
            continue
        meta = _load_json(meta_path, {})
        status = meta.get("status")
        proj = meta.get("project")
        profile = meta.get("profile")
        goal = meta.get("goal_met")
        ec = meta.get("exit_code")
        title = meta.get("title") or ""
        parent = meta.get("parent_run_id") or ""
        print(f"{d.name}\t{status}\tproj={proj}\tprofile={profile}\tgoal_met={goal}\texit={ec}\tparent={parent}\t{title}", flush=True)
    return 0


def cmd_show(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)
    run_dir = p["runs"] / args.run_id
    meta_path = run_dir / "meta.json"
    if not meta_path.exists():
        print(f"❌ unknown run_id: {args.run_id}", file=sys.stderr)
        return 2
    meta = _load_json(meta_path, {})
    print(json.dumps(meta, ensure_ascii=False, indent=2))
    return 0


def cmd_wait(args: argparse.Namespace) -> int:
    """Block until run finishes, then print result JSON. Designed to be run in background."""
    import time

    home = _default_home()
    p = _ensure_init(home)
    run_id = args.run_id
    run_dir = p["runs"] / run_id
    meta_path = run_dir / "meta.json"
    result_path = run_dir / "result.json"
    interval = args.interval
    timeout = args.timeout

    if not meta_path.exists():
        print(f'{{"error": "unknown run_id: {run_id}"}}')
        return 2

    start_time = time.monotonic()
    while True:
        # Check result.json (interactive mode)
        if result_path.exists():
            time.sleep(2)  # let _on_finish update meta

        meta = _load_json(meta_path, {})
        if meta.get("status") == "finished":
            print(json.dumps(meta, ensure_ascii=False, indent=2))
            return 0

        if timeout > 0 and (time.monotonic() - start_time) > timeout:
            meta["_wait_timeout"] = True
            print(json.dumps(meta, ensure_ascii=False, indent=2))
            return 1

        time.sleep(interval)


def cmd_tail(args: argparse.Namespace) -> int:
    home = _default_home()
    p = _ensure_init(home)
    log_path = p["notify_log"]
    with log_path.open("r", encoding="utf-8") as f:
        f.seek(0, os.SEEK_END)
        try:
            while True:
                line = f.readline()
                if line:
                    sys.stdout.write(line)
                    sys.stdout.flush()
                else:
                    subprocess.run(["bash", "-lc", "sleep 0.2"], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except KeyboardInterrupt:
            return 0


def _add_common_exec_flags(sp: argparse.ArgumentParser) -> None:
    sp.add_argument("--profile", default=None, help="Codex profile name (from ~/.codex/config.toml).")
    sp.add_argument("--title", default="")
    sp.add_argument("--prompt-file", default="-", help="Path to prompt file, or '-' for stdin.")
    sp.add_argument("--run-id", default=None, help="Optional explicit run id.")
    sp.add_argument("--tmux-session", default=None, help="tmux session to create the window in.")
    sp.add_argument("--full-auto", action="store_true", default=True, help="Use --full-auto. Default: true.")
    sp.add_argument("--no-full-auto", action="store_false", dest="full_auto")
    sp.add_argument("--sandbox", default=None, help="Override sandbox: read-only | workspace-write | danger-full-access. Default: none (no sandbox).")
    sp.add_argument("--ask-for-approval", default=None, help="Override approval: untrusted | on-failure | on-request | never. Default: none (use --full-auto instead).")
    sp.add_argument("--model", default=None, help="Override model slug, e.g. gpt-5.3-codex-spark")
    sp.add_argument("--ephemeral", action="store_true", default=True, help="Use --ephemeral (no persistent session). Default: true.")
    sp.add_argument("--no-ephemeral", action="store_false", dest="ephemeral", help="Disable ephemeral mode (enables resume).")
    sp.add_argument("--json-events", action="store_true", default=False, help="Capture JSONL events via --json (hides terminal output).")
    sp.add_argument("--no-json-events", action="store_false", dest="json_events")
    sp.add_argument("--output-schema", default=None, help="Path to JSON Schema file for the final response.")
    sp.add_argument("--skip-git-repo-check", action="store_true", help="Allow running outside a Git repo (unsafe).")
    sp.add_argument("--headless", action="store_true", default=False, help="Use codex exec (no UI). NOT recommended — agents run with full TUI by default.")
    sp.add_argument("--watch", action="store_false", dest="headless", help="Use interactive codex with full TUI (default).")


def _build_parser() -> argparse.ArgumentParser:
    p = argparse.ArgumentParser(prog="agentctl")
    sub = p.add_subparsers(dest="cmd", required=True)

    sp = sub.add_parser("init", help="Initialize ~/.ai-orch and seed config/schema/projects.")
    sp.set_defaults(func=cmd_init)

    sp = sub.add_parser("add-project", help="Register a project name -> path.")
    sp.add_argument("name")
    sp.add_argument("path")
    sp.add_argument("--default-profile", default="spark")
    sp.set_defaults(func=cmd_add_project)

    sp = sub.add_parser("start", help="Start a Codex run in a new tmux window.")
    sp.add_argument("--project", default=None, help="Project name (registered) or path. Default: cwd.")
    _add_common_exec_flags(sp)
    sp.set_defaults(func=cmd_start)

    sp = sub.add_parser("resume", help="Resume a previous non-interactive session (codex exec resume).")
    sp.add_argument("--parent-run-id", required=True, help="Run id to resume (uses its stored thread_id).")
    _add_common_exec_flags(sp)
    sp.set_defaults(func=cmd_resume)

    sp = sub.add_parser("_on_finish", help=argparse.SUPPRESS)
    sp.add_argument("--run-id", required=True)
    sp.add_argument("--exit-code", required=True)
    sp.set_defaults(func=cmd_on_finish)

    sp = sub.add_parser("list", help="List recent runs.")
    sp.add_argument("--limit", type=int, default=30)
    sp.set_defaults(func=cmd_list)

    sp = sub.add_parser("show", help="Show run metadata (JSON).")
    sp.add_argument("run_id")
    sp.set_defaults(func=cmd_show)

    sp = sub.add_parser("wait", help="Block until a run finishes, then print result JSON. Use with run_in_background.")
    sp.add_argument("run_id", help="Run id to wait for.")
    sp.add_argument("--interval", type=float, default=5, help="Poll interval in seconds. Default: 5.")
    sp.add_argument("--timeout", type=float, default=0, help="Max wait time in seconds. 0 = no limit. Default: 0.")
    sp.set_defaults(func=cmd_wait)

    sp = sub.add_parser("tail", help="Tail orchestrator notifications (like tail -f).")
    sp.set_defaults(func=cmd_tail)

    return p


def main(argv: list[str]) -> int:
    parser = _build_parser()
    args = parser.parse_args(argv)
    return int(args.func(args))


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
